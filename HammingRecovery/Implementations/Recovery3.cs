// <autogenerated>by special utility</autogenerated>

namespace Force.HammingRecovery.Implementations
{
internal class Recovery3 : IRecovery
{
public int GetBlockSize() { return 4;}
public int GetRecoverySize() { return 3;}
public void Insert(byte[] input, int io, byte[] output, int oo) { output[oo + 0] = (byte)(input[io + 0] ^ input[io + 1] ^ input[io + 3] ^  0);
output[oo + 1] = (byte)(input[io + 0] ^ input[io + 2] ^ input[io + 3] ^  0);
output[oo + 2] = (byte)(input[io + 1] ^ input[io + 2] ^ input[io + 3] ^  0);
}
public bool Recover(byte[] input, int io, byte[] output, int oo) { var r0 = (byte)(output[oo + 0] ^ output[oo + 1] ^ output[oo + 3] ^  0);var f0 = r0 != input[io + 0];
var r1 = (byte)(output[oo + 0] ^ output[oo + 2] ^ output[oo + 3] ^  0);var f1 = r1 != input[io + 1];
var r2 = (byte)(output[oo + 1] ^ output[oo + 2] ^ output[oo + 3] ^  0);var f2 = r2 != input[io + 2];
if (!f0 && !f1 && !f2) { /* no error */ return false; }
else if (f0 && f1 && !f2) output[oo + 0] = (byte)(input[io + 1] ^ output[oo + 2] ^ output[oo + 3]);
else if (f0 && !f1 && f2) output[oo + 1] = (byte)(input[io + 2] ^ output[oo + 2] ^ output[oo + 3]);
else if (!f0 && f1 && f2) output[oo + 2] = (byte)(input[io + 2] ^ output[oo + 1] ^ output[oo + 3]);
else if (f0 && f1 && f2) output[oo + 3] = (byte)(input[io + 2] ^ output[oo + 1] ^ output[oo + 2]);
else { /* error in recovery info. assume, that normal data is ok */ }
return true;
}
}
}
